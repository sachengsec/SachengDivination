<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…­çˆ»æ’ç›˜ Â· å‘¨æ˜“å åœ</title>
    <meta name="description" content="ä¸“ä¸šå…­çˆ»æ’ç›˜åœ¨çº¿å·¥å…·ï¼Œæ”¯æŒæ‰‹åŠ¨æ‘‡å¦ã€è‡ªåŠ¨èµ·å¦ï¼Œæä¾›å®Œæ•´çº³ç”²ã€å…­äº²ã€å…­ç¥ã€ä¸–åº”åˆ†æ">
    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700;900&family=Ma+Shan+Zheng&display=swap"
        rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        :root {
            --bg: #fafafa;
            --card: #ffffff;
            --border: #e0e0e0;
            --primary: #333333;
            --secondary: #666666;
            --accent: #2196f3;
            --text: #333333;
            --text-light: #666666;
            --red: #f44336;
        }

        body {
            font-family: 'Noto Serif SC', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            line-height: 1.6;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px
        }

        /* ===== HEADER ===== */
        .header {
            text-align: center;
            padding: 40px 20px 30px;
        }

        .header h1 {
            font-size: 2rem;
            color: var(--primary);
            font-weight: 400;
            letter-spacing: 4px;
        }

        .header .subtitle {
            color: var(--text-light);
            font-size: 14px;
            margin-top: 8px;
            letter-spacing: 2px;
            font-weight: 300;
        }

        .divider {
            width: 60px;
            height: 1px;
            margin: 20px auto;
            background: var(--border);
        }

        /* ===== CARDS ===== */
        .card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 24px;
            margin-bottom: 20px;
        }

        .card-title {
            font-size: 16px;
            color: var(--primary);
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
            font-weight: 400;
        }

        /* ===== INPUT SECTION ===== */
        .input-row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: end;
            margin-bottom: 16px
        }

        .input-group {
            flex: 1;
            min-width: 200px
        }

        .input-group label {
            display: block;
            font-size: 13px;
            color: var(--text-light);
            margin-bottom: 6px
        }

        .input-group input,
        .input-group select {
            width: 100%;
            padding: 8px 12px;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 2px;
            color: var(--text);
            font-family: inherit;
            font-size: 14px;
        }

        .input-group input:focus,
        .input-group select:focus {
            outline: none;
            border-color: var(--accent);
        }

        /* ===== BUTTONS ===== */
        .btn-row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 20px 0
        }

        .btn {
            padding: 10px 20px;
            border: 1px solid var(--border);
            border-radius: 2px;
            background: var(--card);
            color: var(--text);
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
            transition: all .2s;
        }

        .btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .btn-primary {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .btn-primary:hover {
            background: #1976d2;
            border-color: #1976d2;
        }

        .btn-sm {
            padding: 6px 12px;
            font-size: 13px
        }

        /* ===== COIN ANIMATION ===== */
        .coin-area {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            min-height: 60px
        }

        .coin {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: normal;
            border: 2px solid var(--border);
            background: var(--card);
            color: var(--text);
        }

        .coin.flipping {
            animation: coinFlip .6s ease-in-out
        }

        @keyframes coinFlip {
            0% {
                transform: rotateY(0)
            }

            50% {
                transform: rotateY(900deg)
            }

            100% {
                transform: rotateY(1800deg)
            }
        }

        /* ===== MANUAL SHAKE ===== */
        .manual-panel {
            display: none;
            text-align: center
        }

        .manual-panel.active {
            display: block
        }

        .shake-progress {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin: 15px 0
        }

        .shake-dot {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: var(--text-light);
            background: var(--card);
        }

        .shake-dot.done {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .shake-dot.current {
            border-color: var(--accent);
        }

        .coin-btns {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 15px 0
        }

        .coin-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--text);
            font-size: 20px;
            cursor: pointer;
            transition: all .2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .coin-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .coin-result-text {
            color: var(--text-light);
            font-size: 13px;
            margin-top: 5px
        }

        /* ===== HEXAGRAM DISPLAY ===== */
        .result-area {
            display: none
        }

        .result-area.active {
            display: block;
            animation: fadeIn .4s ease
        }

        @keyframes fadeIn {
            from {
                opacity: 0
            }

            to {
                opacity: 1
            }
        }

        .hex-container {
            display: flex;
            gap: 30px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px
        }

        .hex-panel {
            flex: 1;
            min-width: 300px;
            max-width: 400px
        }

        .hex-panel-title {
            text-align: center;
            font-size: 18px;
            color: var(--primary);
            margin-bottom: 10px;
            font-weight: 400;
            letter-spacing: 2px;
        }

        .hex-panel-subtitle {
            text-align: center;
            font-size: 12px;
            color: var(--text-light);
            margin-bottom: 15px
        }

        .hex-table {
            width: 100%
        }

        .hex-row {
            display: grid;
            grid-template-columns: 55px 65px 1fr 85px 35px;
            align-items: center;
            padding: 8px 4px;
            border-bottom: 1px solid var(--border);
            gap: 4px;
        }

        .hex-row:hover {
            background: #f5f5f5
        }

        .hex-spirit {
            font-size: 12px;
            color: var(--text-light)
        }

        .hex-relative {
            font-size: 13px;
            color: var(--text)
        }

        .hex-line-wrap {
            display: flex;
            justify-content: center;
            padding: 4px 0
        }

        .hex-line {
            position: relative;
            width: 100%;
            height: 8px;
            display: flex;
            gap: 8px;
            justify-content: center
        }

        .yang-line {
            width: 100%;
            max-width: 100px;
            height: 4px;
            background: var(--primary);
            border-radius: 1px;
        }

        .yin-line {
            display: flex;
            gap: 10px;
            width: 100%;
            max-width: 100px;
            justify-content: center;
        }

        .yin-half {
            flex: 1;
            height: 4px;
            background: var(--primary);
            border-radius: 1px;
        }

        .hex-nayin {
            font-size: 12px;
            color: var(--text-light);
            text-align: right;
            white-space: nowrap
        }

        .hex-shiying {
            font-size: 12px;
            color: var(--red);
            font-weight: normal;
        }

        .moving-marker {
            position: absolute;
            right: -18px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 11px;
            color: var(--red);
        }

        .line-moving .yang-line {
            background: var(--red);
        }

        .line-moving .yin-half {
            background: var(--red);
        }

        /* ===== INFO TAGS ===== */
        .info-tags {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin: 15px 0;
            justify-content: center
        }

        .tag {
            padding: 4px 12px;
            border-radius: 2px;
            font-size: 12px;
            background: #f5f5f5;
            border: 1px solid var(--border);
            color: var(--text-light);
        }

        /* ===== ANALYSIS ===== */
        .analysis-section {
            margin-top: 10px
        }

        .analysis-block {
            padding: 16px;
            margin-bottom: 12px;
            border-radius: 2px;
            background: #f9f9f9;
            border-left: 2px solid var(--accent);
        }

        .analysis-block h3 {
            font-size: 14px;
            color: var(--primary);
            margin-bottom: 8px;
            font-weight: 400;
        }

        .analysis-block p {
            font-size: 13px;
            line-height: 1.8;
            color: var(--text)
        }

        .analysis-block .highlight {
            color: var(--accent);
            font-weight: normal;
        }

        .analysis-block .warn {
            color: var(--red)
        }

        .analysis-block .good {
            color: #4caf50
        }

        /* ===== FUSHEN ===== */
        .fushen-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px
        }

        .fushen-table th,
        .fushen-table td {
            padding: 8px 12px;
            font-size: 13px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .fushen-table th {
            color: var(--primary);
            font-weight: 400;
        }

        /* ===== RESPONSIVE ===== */
        @media(max-width:768px) {
            .container {
                padding: 10px
            }

            .card {
                padding: 16px
            }

            .hex-container {
                gap: 15px
            }

            .hex-panel {
                min-width: 100%
            }

            .hex-row {
                grid-template-columns: 50px 60px 1fr 75px 30px;
                font-size: 12px
            }

            .input-row {
                flex-direction: column
            }

            .input-group {
                min-width: 100%
            }
        }

        @media(max-width:400px) {
            .hex-row {
                grid-template-columns: 40px 50px 1fr 70px 24px;
                gap: 2px;
                padding: 6px 2px
            }

            .hex-nayin {
                font-size: 11px
            }
        }

        .footer {
            text-align: center;
            padding: 30px;
            color: var(--text-light);
            font-size: 12px;
        }
    </style>
</head>

<body>

    <div class="container">
        <!-- HEADER -->
        <div class="header">
            <h1>å…­çˆ»æ’ç›˜</h1>
            <div class="subtitle">å‘¨ æ˜“ Â· çº³ ç”² Â· å  åœ</div>
            <div class="divider"></div>
        </div>

        <!-- INPUT -->
        <div class="card" id="inputCard">
            <div class="card-title">èµ·å¦è®¾ç½®</div>
            <div class="input-row">
                <div class="input-group">
                    <label>æ±‚æµ‹äº‹é¡¹</label>
                    <input type="text" id="question" placeholder="è¯·è¾“å…¥æ‰€æµ‹ä¹‹äº‹ï¼ˆå¯é€‰ï¼‰">
                </div>
                <div class="input-group" style="max-width:160px">
                    <label>äº‹é¡¹ç±»åˆ«</label>
                    <select id="category">
                        <option value="">è¯·é€‰æ‹©</option>
                        <option value="wealth">æ±‚è´¢</option>
                        <option value="career">äº‹ä¸š/æ±‚å®˜</option>
                        <option value="marriage">å©šå§»æ„Ÿæƒ…</option>
                        <option value="health">ç–¾ç—…å¥åº·</option>
                        <option value="travel">å‡ºè¡Œ</option>
                        <option value="lawsuit">å®˜å¸è¯‰è®¼</option>
                        <option value="lost">å¯»äººå¯»ç‰©</option>
                        <option value="study">å­¦ä¸šè€ƒè¯•</option>
                        <option value="other">å…¶ä»–</option>
                    </select>
                </div>
            </div>
            <div class="btn-row">
                <button class="btn btn-primary" onclick="autoShake()">âš… è‡ªåŠ¨èµ·å¦</button>
                <button class="btn" onclick="startManual()">ğŸª™ æ‰‹åŠ¨æ‘‡å¦</button>
                <button class="btn" onclick="timeShake()">ğŸ• æ—¶é—´èµ·å¦</button>
                <button class="btn" onclick="startCustom()">ğŸ“– æŒ‡å®šå¦è±¡</button>
            </div>

            <!-- MANUAL PANEL -->
            <div class="manual-panel" id="manualPanel">
                <div class="divider"></div>
                <p style="color:var(--text-light);font-size:13px;margin-bottom:10px">ç‚¹å‡»é“œé’±é€‰æ‹©æ­£ï¼ˆå­—ï¼‰æˆ–åï¼ˆèƒŒï¼‰ï¼Œæ¯çˆ»æŠ•ä¸‰æ¬¡</p>
                <div class="shake-progress" id="shakeProgress"></div>
                <div class="coin-area" id="coinArea"></div>
                <div class="coin-btns">
                    <button class="coin-btn" onclick="manualCoin(1)" title="æ­£é¢ï¼ˆå­—ï¼‰">å­—</button>
                    <button class="coin-btn" onclick="manualCoin(0)" title="åé¢ï¼ˆèƒŒï¼‰">èƒŒ</button>
                </div>
                <div class="coin-result-text" id="coinResultText"></div>
                <button class="btn btn-sm" onclick="cancelManual()" style="margin-top:10px">å–æ¶ˆ</button>
            </div>

            <!-- CUSTOM HEXAGRAM PANEL -->
            <div class="manual-panel" id="customPanel">
                <div class="divider"></div>
                <p style="color:var(--text-light);font-size:13px;margin-bottom:10px">é€‰æ‹©å¦è±¡å’ŒåŠ¨çˆ»</p>
                <div class="input-group" style="max-width:100%;margin-bottom:16px">
                    <label>é€‰æ‹©å¦è±¡</label>
                    <select id="customHexSelect" style="width:100%">
                        <option value="">è¯·é€‰æ‹©</option>
                    </select>
                </div>
                <div style="margin-bottom:16px">
                    <label
                        style="display:block;font-size:13px;color:var(--text-light);margin-bottom:8px">é€‰æ‹©åŠ¨çˆ»ï¼ˆå¯å¤šé€‰ï¼‰</label>
                    <div style="display:flex;gap:8px;flex-wrap:wrap;justify-content:center">
                        <label style="display:flex;align-items:center;gap:4px;cursor:pointer">
                            <input type="checkbox" id="customMove0" value="0" style="cursor:pointer">
                            <span style="font-size:13px">åˆçˆ»</span>
                        </label>
                        <label style="display:flex;align-items:center;gap:4px;cursor:pointer">
                            <input type="checkbox" id="customMove1" value="1" style="cursor:pointer">
                            <span style="font-size:13px">äºŒçˆ»</span>
                        </label>
                        <label style="display:flex;align-items:center;gap:4px;cursor:pointer">
                            <input type="checkbox" id="customMove2" value="2" style="cursor:pointer">
                            <span style="font-size:13px">ä¸‰çˆ»</span>
                        </label>
                        <label style="display:flex;align-items:center;gap:4px;cursor:pointer">
                            <input type="checkbox" id="customMove3" value="3" style="cursor:pointer">
                            <span style="font-size:13px">å››çˆ»</span>
                        </label>
                        <label style="display:flex;align-items:center;gap:4px;cursor:pointer">
                            <input type="checkbox" id="customMove4" value="4" style="cursor:pointer">
                            <span style="font-size:13px">äº”çˆ»</span>
                        </label>
                        <label style="display:flex;align-items:center;gap:4px;cursor:pointer">
                            <input type="checkbox" id="customMove5" value="5" style="cursor:pointer">
                            <span style="font-size:13px">ä¸Šçˆ»</span>
                        </label>
                    </div>
                </div>
                <div style="display:flex;gap:10px;justify-content:center">
                    <button class="btn btn-primary" onclick="confirmCustom()">ç¡®å®š</button>
                    <button class="btn btn-sm" onclick="cancelCustom()">å–æ¶ˆ</button>
                </div>
            </div>
        </div>

        <!-- RESULT -->
        <div class="result-area" id="resultArea">
            <!-- DateTime Info -->
            <div class="card">
                <div class="card-title">èµ·å¦ä¿¡æ¯</div>
                <div class="info-tags" id="infoTags"></div>
            </div>

            <!-- Hexagram Display -->
            <div class="card">
                <div class="card-title">å¦è±¡æ’ç›˜</div>
                <div class="hex-container" id="hexContainer"></div>
            </div>

            <!-- ä¼ç¥ -->
            <div class="card" id="fushenCard" style="display:none">
                <div class="card-title">ä¼ç¥</div>
                <div id="fushenContent"></div>
            </div>

            <!-- Analysis -->
            <div class="card">
                <div class="card-title">å¦è±¡åˆ†æ</div>
                <div class="analysis-section" id="analysisSection"></div>
            </div>

            <div class="btn-row">
                <button class="btn" onclick="exportToClipboard()">ğŸ“‹ å¤åˆ¶å¦è±¡</button>
                <button class="btn" onclick="autoShake()">é‡æ–°èµ·å¦</button>
            </div>
        </div>
    </div>

    <div class="footer">å…­çˆ»æ’ç›˜ Â· ä»…ä¾›å‚è€ƒ Â· ä¸å¯è¿·ä¿¡</div>

    <script>
        let currentResult = null; // Store current result for export

        // ========== CONSTANTS ==========
        const TIAN_GAN = ['ç”²', 'ä¹™', 'ä¸™', 'ä¸', 'æˆŠ', 'å·±', 'åºš', 'è¾›', 'å£¬', 'ç™¸'];
        const DI_ZHI = ['å­', 'ä¸‘', 'å¯…', 'å¯', 'è¾°', 'å·³', 'åˆ', 'æœª', 'ç”³', 'é…‰', 'æˆŒ', 'äº¥'];
        const WU_XING = ['é‡‘', 'æœ¨', 'æ°´', 'ç«', 'åœŸ'];
        const DZ_WX = [2, 4, 1, 1, 4, 3, 3, 4, 0, 0, 4, 2]; // åœ°æ”¯å¯¹åº”äº”è¡Œ: å­æ°´ä¸‘åœŸå¯…æœ¨å¯æœ¨è¾°åœŸå·³ç«åˆç«æœªåœŸç”³é‡‘é…‰é‡‘æˆŒåœŸäº¥æ°´
        const WX_NAMES = { 0: 'é‡‘', 1: 'æœ¨', 2: 'æ°´', 3: 'ç«', 4: 'åœŸ' };
        const LIU_QIN = ['å…„å¼Ÿ', 'çˆ¶æ¯', 'å®˜é¬¼', 'å¦»è´¢', 'å­å­™'];
        // å…­äº²å…³ç³»: selfWX -> targetWX => å…­äº²index
        // åŒæˆ‘=å…„å¼Ÿ0, ç”Ÿæˆ‘=çˆ¶æ¯1, å…‹æˆ‘=å®˜é¬¼2, æˆ‘å…‹=å¦»è´¢3, æˆ‘ç”Ÿ=å­å­™4
        const SHENG = [2, 3, 0, 4, 1]; // é‡‘ç”Ÿæ°´,æœ¨ç”Ÿç«,æ°´ç”Ÿæœ¨,ç«ç”ŸåœŸ,åœŸç”Ÿé‡‘ â†’ Xç”Ÿçš„=SHENG[X]
        const KE = [1, 4, 3, 0, 2]; // é‡‘å…‹æœ¨,æœ¨å…‹åœŸ,æ°´å…‹ç«,ç«å…‹é‡‘,åœŸå…‹æ°´ â†’ Xå…‹çš„=KE[X]
        const LIU_SHEN = ['é’é¾™', 'æœ±é›€', 'å‹¾é™ˆ', 'è£è›‡', 'ç™½è™', 'ç„æ­¦'];
        const TRIGRAM_NAMES = ['å¤', 'è‰®', 'å', 'å·½', 'éœ‡', 'ç¦»', 'å…‘', 'ä¹¾'];
        const TRIGRAM_WX = [4, 4, 2, 1, 1, 3, 0, 0]; // å¤åœŸ,è‰®åœŸ,åæ°´,å·½æœ¨,éœ‡æœ¨,ç¦»ç«,å…‘é‡‘,ä¹¾é‡‘
        const TRIGRAM_NATURE = ['åœ°', 'å±±', 'æ°´', 'é£', 'é›·', 'ç«', 'æ³½', 'å¤©'];

        // çº³ç”²: [å¤©å¹²index, [åœ°æ”¯index Ã— 3]] for inner and outer
        const NA_JIA_INNER = [
            [1, [7, 5, 3]],   // å¤: ä¹™ æœªå·³å¯
            [2, [4, 6, 8]],   // è‰®: ä¸™ è¾°åˆç”³
            [4, [2, 4, 6]],   // å: æˆŠ å¯…è¾°åˆ
            [7, [1, 11, 9]],  // å·½: è¾› ä¸‘äº¥é…‰
            [6, [0, 2, 4]],   // éœ‡: åºš å­å¯…è¾°
            [5, [3, 1, 11]],  // ç¦»: å·± å¯ä¸‘äº¥
            [3, [5, 3, 1]],   // å…‘: ä¸ å·³å¯ä¸‘
            [0, [0, 2, 4]],   // ä¹¾: ç”² å­å¯…è¾°
        ];
        const NA_JIA_OUTER = [
            [9, [1, 11, 9]],  // å¤: ç™¸ ä¸‘äº¥é…‰
            [2, [10, 0, 2]],  // è‰®: ä¸™ æˆŒå­å¯…
            [4, [8, 10, 0]],  // å: æˆŠ ç”³æˆŒå­
            [7, [7, 5, 3]],   // å·½: è¾› æœªå·³å¯
            [6, [6, 8, 10]],  // éœ‡: åºš åˆç”³æˆŒ
            [5, [9, 7, 5]],   // ç¦»: å·± é…‰æœªå·³
            [3, [11, 9, 7]],  // å…‘: ä¸ äº¥é…‰æœª
            [8, [6, 8, 10]],  // ä¹¾: å£¬ åˆç”³æˆŒ
        ];

        // 64å¦å [upper][lower], trigram index: å¤0 è‰®1 å2 å·½3 éœ‡4 ç¦»5 å…‘6 ä¹¾7
        const GUA_NAMES = [
            ['å¤ä¸ºåœ°', 'å±±åœ°å‰¥', 'æ°´åœ°æ¯”', 'é£åœ°è§‚', 'é›·åœ°è±«', 'ç«åœ°æ™‹', 'æ³½åœ°èƒ', 'å¤©åœ°å¦'],
            ['åœ°å±±è°¦', 'è‰®ä¸ºå±±', 'æ°´å±±è¹‡', 'é£å±±æ¸', 'é›·å±±å°è¿‡', 'ç«å±±æ—…', 'æ³½å±±å’¸', 'å¤©å±±é'],
            ['åœ°æ°´å¸ˆ', 'å±±æ°´è’™', 'åä¸ºæ°´', 'é£æ°´æ¶£', 'æ°´é›·å±¯', 'ç«æ°´æœªæµ', 'æ³½æ°´å›°', 'å¤©æ°´è®¼'],
            ['åœ°é£å‡', 'å±±é£è›Š', 'æ°´é£äº•', 'å·½ä¸ºé£', 'é›·é£æ’', 'ç«é£é¼', 'æ³½é£å¤§è¿‡', 'å¤©é£å§¤'],
            ['åœ°é›·å¤', 'å±±é›·é¢', 'é›·æ°´è§£', 'é£é›·ç›Š', 'éœ‡ä¸ºé›·', 'ç«é›·å™¬å—‘', 'æ³½é›·éš', 'å¤©é›·æ— å¦„'],
            ['åœ°ç«æ˜å¤·', 'å±±ç«è´²', 'æ°´ç«æ—¢æµ', 'é£ç«å®¶äºº', 'é›·ç«ä¸°', 'ç¦»ä¸ºç«', 'æ³½ç«é©', 'å¤©ç«åŒäºº'],
            ['åœ°æ³½ä¸´', 'å±±æ³½æŸ', 'æ°´æ³½èŠ‚', 'é£æ³½ä¸­å­š', 'é›·æ³½å½’å¦¹', 'ç«æ³½ç½', 'å…‘ä¸ºæ³½', 'å¤©æ³½å±¥'],
            ['åœ°å¤©æ³°', 'å±±å¤©å¤§ç•œ', 'æ°´å¤©éœ€', 'é£å¤©å°ç•œ', 'é›·å¤©å¤§å£®', 'ç«å¤©å¤§æœ‰', 'æ³½å¤©å¤¬', 'ä¹¾ä¸ºå¤©'],
        ];

        // ========== PALACE (å…«å®«) ==========
        // Generate palace assignments: palaceMap[hexKey] = {palace, position}
        // hexKey = upperTrigram * 8 + lowerTrigram
        const palaceMap = {};
        const TRIGRAM_BITS = [[0, 0, 0], [0, 0, 1], [0, 1, 0], [0, 1, 1], [1, 0, 0], [1, 0, 1], [1, 1, 0], [1, 1, 1]];

        function initPalaces() {
            for (let p = 0; p < 8; p++) {
                const bits = TRIGRAM_BITS[p];
                let cur = [...bits, ...bits]; // 6 lines, bottom to top
                for (let pos = 0; pos < 8; pos++) {
                    if (pos === 0) {
                        cur = [...bits, ...bits];
                    } else if (pos >= 1 && pos <= 5) {
                        cur[pos - 1] = 1 - cur[pos - 1];
                    } else if (pos === 6) { // æ¸¸é­‚: toggle line 4 back
                        cur[3] = 1 - cur[3];
                    } else if (pos === 7) { // å½’é­‚: restore lower trigram
                        cur[0] = bits[0]; cur[1] = bits[1]; cur[2] = bits[2];
                    }
                    const lower = cur[0] * 4 + cur[1] * 2 + cur[2];
                    const upper = cur[3] * 4 + cur[4] * 2 + cur[5];
                    const key = upper * 8 + lower;
                    if (!(key in palaceMap)) {
                        palaceMap[key] = { palace: p, position: pos };
                    }
                }
            }
        }
        initPalaces();

        // ä¸–åº” by position in palace
        const SHI_YING = [
            [5, 2], // å…«çº¯: ä¸–6(idx5) åº”3(idx2)
            [0, 3], // ä¸€ä¸–
            [1, 4], // äºŒä¸–
            [2, 5], // ä¸‰ä¸–
            [3, 0], // å››ä¸–
            [4, 1], // äº”ä¸–
            [3, 0], // æ¸¸é­‚
            [2, 5], // å½’é­‚
        ];
        const POS_NAMES = ['å…«çº¯å¦', 'ä¸€ä¸–å¦', 'äºŒä¸–å¦', 'ä¸‰ä¸–å¦', 'å››ä¸–å¦', 'äº”ä¸–å¦', 'æ¸¸é­‚å¦', 'å½’é­‚å¦'];

        // ========== CALENDAR ==========
        function julianDay(y, m, d) {
            const a = Math.floor((14 - m) / 12);
            const yy = y + 4800 - a;
            const mm = m + 12 * a - 3;
            return d + Math.floor((153 * mm + 2) / 5) + 365 * yy +
                Math.floor(yy / 4) - Math.floor(yy / 100) + Math.floor(yy / 400) - 32045;
        }

        function getDayGanZhi(date) {
            const jd = julianDay(date.getFullYear(), date.getMonth() + 1, date.getDate());
            return { gan: ((jd + 9) % 10 + 10) % 10, zhi: ((jd + 1) % 12 + 12) % 12 };
        }

        function getYearGanZhi(y) {
            return { gan: ((y - 4) % 10 + 10) % 10, zhi: ((y - 4) % 12 + 12) % 12 };
        }

        // æœˆå»º (approximate by solar terms)
        function getMonthZhi(month, day) {
            // Solar term boundaries (approximate)
            const terms = [
                [2, 4], [3, 6], [4, 5], [5, 6], [6, 6], [7, 7],
                [8, 7], [9, 8], [10, 8], [11, 7], [12, 7], [1, 5]
            ];
            // æœˆæ”¯: å¯…=2æœˆ, å¯=3æœˆ ...
            let mz;
            for (let i = 0; i < 12; i++) {
                const [tm, td] = terms[i];
                const [nm, nd] = terms[(i + 1) % 12];
                if (month === tm && day >= td) { mz = (2 + i) % 12; break; }
                if (month === nm && day < nd) { mz = (2 + i) % 12; break; }
            }
            if (mz === undefined) mz = (month + 1) % 12;
            return mz;
        }

        function getMonthGan(yearGan, monthZhi) {
            // å¹´ä¸Šèµ·æœˆæ³•
            const base = [2, 4, 6, 8, 0]; // ç”²å·±å¹´èµ·ä¸™å¯…
            const startGan = base[yearGan % 5];
            const offset = ((monthZhi - 2) % 12 + 12) % 12;
            return (startGan + offset) % 10;
        }

        function formatGanZhi(g, z) { return TIAN_GAN[g] + DI_ZHI[z]; }
        function getGanZhiWX(z) { return DZ_WX[z]; }

        // ========== LIUQIN ==========
        function getLiuQin(selfWX, targetWX) {
            if (targetWX === selfWX) return 0; // å…„å¼Ÿ
            // ç”Ÿæˆ‘è€…
            if (SHENG[targetWX] === selfWX) return 1; // çˆ¶æ¯
            // å…‹æˆ‘è€…
            if (KE[targetWX] === selfWX) return 2; // å®˜é¬¼
            // æˆ‘å…‹è€…
            if (KE[selfWX] === targetWX) return 3; // å¦»è´¢
            // æˆ‘ç”Ÿè€…
            if (SHENG[selfWX] === targetWX) return 4; // å­å­™
            return 0;
        }

        // ========== SIX SPIRITS ==========
        function getLiuShen(dayGan) {
            // ç”²ä¹™èµ·é’é¾™, ä¸™ä¸èµ·æœ±é›€, æˆŠå·±èµ·å‹¾é™ˆ, åºšè¾›èµ·ç™½è™, å£¬ç™¸èµ·ç„æ­¦
            const startIdx = Math.floor(dayGan / 2);
            const order = [];
            for (let i = 0; i < 6; i++) order.push(LIU_SHEN[(startIdx + i) % 6]);
            return order; // [åˆçˆ», äºŒçˆ», ..., ä¸Šçˆ»]
        }

        // ========== HEXAGRAM ANALYSIS ENGINE ==========
        function analyzeHexagram(lines, date) {
            // lines: array of 6 values (6=è€é˜´, 7=å°‘é˜³, 8=å°‘é˜´, 9=è€é˜³) from bottom to top
            const dayGZ = getDayGanZhi(date);
            const yearGZ = getYearGanZhi(date.getFullYear());
            const monthZhi = getMonthZhi(date.getMonth() + 1, date.getDate());
            const monthGan = getMonthGan(yearGZ.gan, monthZhi);

            // Determine original lines (yang/yin)
            const original = lines.map(v => (v === 7 || v === 9) ? 1 : 0);
            const moving = lines.map(v => (v === 6 || v === 9));
            const changed = original.map((v, i) => moving[i] ? 1 - v : v);

            // Trigrams
            const lowerOrig = original[0] * 4 + original[1] * 2 + original[2];
            const upperOrig = original[3] * 4 + original[4] * 2 + original[5];
            const lowerChg = changed[0] * 4 + changed[1] * 2 + changed[2];
            const upperChg = changed[3] * 4 + changed[4] * 2 + changed[5];

            const hasMoving = moving.some(m => m);

            // Palace & ä¸–åº”
            const hexKey = upperOrig * 8 + lowerOrig;
            const pInfo = palaceMap[hexKey] || { palace: 0, position: 0 };
            const palaceWX = TRIGRAM_WX[pInfo.palace];
            const [shiIdx, yingIdx] = SHI_YING[pInfo.position];

            // å˜å¦ä¸–åº”
            let chgShiIdx = -1, chgYingIdx = -1;
            if (hasMoving) {
                const chgKey = upperChg * 8 + lowerChg;
                const cpInfo = palaceMap[chgKey] || { palace: 0, position: 0 };
                [chgShiIdx, chgYingIdx] = SHI_YING[cpInfo.position];
            }

            // çº³ç”² for original
            const naJiaOrig = [];
            for (let i = 0; i < 6; i++) {
                const tri = i < 3 ? lowerOrig : upperOrig;
                const pos = i < 3 ? i : i - 3;
                const nj = i < 3 ? NA_JIA_INNER[tri] : NA_JIA_OUTER[tri];
                const gan = nj[0];
                const zhi = nj[1][pos];
                const wx = DZ_WX[zhi];
                const lq = getLiuQin(palaceWX, wx);
                naJiaOrig.push({ gan, zhi, wx, lq });
            }

            // çº³ç”² for changed
            const naJiaChg = [];
            if (hasMoving) {
                for (let i = 0; i < 6; i++) {
                    const tri = i < 3 ? lowerChg : upperChg;
                    const pos = i < 3 ? i : i - 3;
                    const nj = i < 3 ? NA_JIA_INNER[tri] : NA_JIA_OUTER[tri];
                    const gan = nj[0];
                    const zhi = nj[1][pos];
                    const wx = DZ_WX[zhi];
                    const chgKey = upperChg * 8 + lowerChg;
                    const cpInfo = palaceMap[chgKey] || { palace: 0, position: 0 };
                    const cpWX = TRIGRAM_WX[cpInfo.palace];
                    const lq = getLiuQin(cpWX, wx);
                    naJiaChg.push({ gan, zhi, wx, lq });
                }
            }

            // å…­ç¥
            const liuShen = getLiuShen(dayGZ.gan);

            // ä¼ç¥
            const presentLQ = new Set(naJiaOrig.map(n => n.lq));
            const fuShen = [];
            for (let lq = 0; lq < 5; lq++) {
                if (!presentLQ.has(lq)) {
                    // Find in pure palace hexagram
                    const pureBits = TRIGRAM_BITS[pInfo.palace];
                    const pureLower = pureBits[0] * 4 + pureBits[1] * 2 + pureBits[2];
                    const pureUpper = pureLower; // pure hexagram has same upper and lower
                    for (let i = 0; i < 6; i++) {
                        const tri = i < 3 ? pureLower : pureUpper;
                        const pos = i < 3 ? i : i - 3;
                        const nj = i < 3 ? NA_JIA_INNER[tri] : NA_JIA_OUTER[tri];
                        const wx = DZ_WX[nj[1][pos]];
                        const flq = getLiuQin(palaceWX, wx);
                        if (flq === lq) {
                            fuShen.push({
                                lqName: LIU_QIN[lq],
                                ganZhi: TIAN_GAN[nj[0]] + DI_ZHI[nj[1][pos]],
                                wx: WX_NAMES[wx],
                                underLine: i,
                                underLQ: LIU_QIN[naJiaOrig[i].lq],
                                underGZ: TIAN_GAN[naJiaOrig[i].gan] + DI_ZHI[naJiaOrig[i].zhi],
                            });
                            break;
                        }
                    }
                }
            }

            return {
                original, changed, moving, hasMoving,
                lowerOrig, upperOrig, lowerChg, upperChg,
                hexNameOrig: GUA_NAMES[upperOrig][lowerOrig],
                hexNameChg: hasMoving ? GUA_NAMES[upperChg][lowerChg] : null,
                palace: pInfo.palace, palaceName: TRIGRAM_NAMES[pInfo.palace],
                palaceWX, posName: POS_NAMES[pInfo.position],
                shiIdx, yingIdx,
                chgShiIdx, chgYingIdx,
                naJiaOrig, naJiaChg, liuShen, fuShen,
                dayGZ, yearGZ, monthZhi, monthGan,
                lines
            };
        }

        // ========== YONGSHEN (ç”¨ç¥) ==========
        function getYongShen(category) {
            // ç”¨ç¥ by category
            const map = {
                wealth: { lq: 3, name: 'å¦»è´¢', desc: 'æ±‚è´¢ä»¥å¦»è´¢çˆ»ä¸ºç”¨ç¥' },
                career: { lq: 2, name: 'å®˜é¬¼', desc: 'æ±‚å®˜äº‹ä¸šä»¥å®˜é¬¼çˆ»ä¸ºç”¨ç¥' },
                marriage: { lq: 3, name: 'å¦»è´¢/å®˜é¬¼', desc: 'ç”·æµ‹å©šä»¥å¦»è´¢ä¸ºç”¨ç¥ï¼Œå¥³æµ‹å©šä»¥å®˜é¬¼ä¸ºç”¨ç¥' },
                health: { lq: 2, name: 'å®˜é¬¼', desc: 'æµ‹ç—…ä»¥å®˜é¬¼çˆ»ä¸ºç”¨ç¥ï¼ˆä»£è¡¨ç–¾ç—…ï¼‰' },
                travel: { lq: 4, name: 'å­å­™', desc: 'å‡ºè¡Œä»¥å­å­™çˆ»ä¸ºç”¨ç¥ï¼Œä¸–çˆ»ä»£è¡¨è‡ªå·±' },
                lawsuit: { lq: 2, name: 'å®˜é¬¼', desc: 'å®˜å¸ä»¥å®˜é¬¼çˆ»ä¸ºç”¨ç¥' },
                lost: { lq: 3, name: 'å¦»è´¢', desc: 'å¯»ç‰©ä»¥å¦»è´¢çˆ»ä¸ºç”¨ç¥ï¼Œå¯»äººä»¥ç”¨çˆ»ä¸ºç”¨' },
                study: { lq: 1, name: 'çˆ¶æ¯', desc: 'å­¦ä¸šä»¥çˆ¶æ¯çˆ»ä¸ºç”¨ç¥' },
                other: null,
            };
            return map[category] || null;
        }

        // ========== TEXT ANALYSIS ==========
        function generateAnalysis(result, category) {
            const blocks = [];
            const palWX = WX_NAMES[result.palaceWX];
            const monthWX = WX_NAMES[DZ_WX[result.monthZhi]];
            const dayWX = WX_NAMES[DZ_WX[result.dayGZ.zhi]];

            // åŸºæœ¬å¦è±¡
            let basic = `æœ¬å¦ <span class="highlight">${result.hexNameOrig}</span>ï¼Œå±${result.palaceName}å®«ï¼ˆ${palWX}ï¼‰ï¼Œä¸º${result.posName}ã€‚`;
            if (result.hasMoving) {
                basic += `å˜å¦ <span class="highlight">${result.hexNameChg}</span>ã€‚`;
                const movingLines = result.moving.map((m, i) => m ? `${'åˆäºŒä¸‰å››äº”ä¸Š'[i]}çˆ»` : null).filter(Boolean);
                basic += `åŠ¨çˆ»ï¼š${movingLines.join('ã€')}ã€‚`;
            } else {
                basic += 'æ— åŠ¨çˆ»ï¼Œå¦è±¡å®‰é™ã€‚';
            }
            blocks.push({ title: 'å¦è±¡æ¦‚è¦', content: basic });

            // ä¸–åº”åˆ†æ
            const shiNJ = result.naJiaOrig[result.shiIdx];
            const yingNJ = result.naJiaOrig[result.yingIdx];
            let shiying = `ä¸–çˆ»åœ¨${'åˆäºŒä¸‰å››äº”ä¸Š'[result.shiIdx]}çˆ»ï¼Œ${LIU_QIN[shiNJ.lq]}${TIAN_GAN[shiNJ.gan]}${DI_ZHI[shiNJ.zhi]}${WX_NAMES[shiNJ.wx]}ï¼›`;
            shiying += `åº”çˆ»åœ¨${'åˆäºŒä¸‰å››äº”ä¸Š'[result.yingIdx]}çˆ»ï¼Œ${LIU_QIN[yingNJ.lq]}${TIAN_GAN[yingNJ.gan]}${DI_ZHI[yingNJ.zhi]}${WX_NAMES[yingNJ.wx]}ã€‚`;

            // ä¸–åº”å…³ç³»
            const shiWX = shiNJ.wx, yingWX = yingNJ.wx;
            if (shiWX === yingWX) shiying += 'ä¸–åº”æ¯”å’Œï¼ŒåŒæ–¹æ„è§ä¸€è‡´ã€‚';
            else if (SHENG[shiWX] === yingWX) shiying += 'ä¸–ç”Ÿåº”ï¼Œä¸»åŠ¨ä»˜å‡ºæ–¹ä¸ºæˆ‘ã€‚';
            else if (SHENG[yingWX] === shiWX) shiying += 'åº”ç”Ÿä¸–ï¼Œä»–æ–¹æœ‰åŠ©äºæˆ‘ã€‚';
            else if (KE[shiWX] === yingWX) shiying += 'ä¸–å…‹åº”ï¼Œæˆ‘å¯åˆ¶çº¦å¯¹æ–¹ã€‚';
            else if (KE[yingWX] === shiWX) shiying += 'åº”å…‹ä¸–ï¼Œå¯¹æ–¹æœ‰åˆ¶çº¦ä¹‹åŠ¿ã€‚';
            blocks.push({ title: 'ä¸–åº”åˆ†æ', content: shiying });

            // ç”¨ç¥åˆ†æ
            const ys = getYongShen(category);
            if (ys) {
                let ysContent = ys.desc + 'ã€‚';
                // Find ç”¨ç¥ lines
                const ysLines = result.naJiaOrig.map((nj, i) => ({ ...nj, idx: i }))
                    .filter(nj => nj.lq === ys.lq);
                if (ysLines.length > 0) {
                    ysLines.forEach(line => {
                        const pos = 'åˆäºŒä¸‰å››äº”ä¸Š'[line.idx];
                        const gz = TIAN_GAN[line.gan] + DI_ZHI[line.zhi];
                        const wx = WX_NAMES[line.wx];
                        ysContent += `ç”¨ç¥${LIU_QIN[line.lq]}åœ¨${pos}çˆ»ï¼Œ${gz}${wx}`;

                        // æœˆå»ºå¯¹ç”¨ç¥
                        const mwx = DZ_WX[result.monthZhi];
                        if (SHENG[mwx] === line.wx) ysContent += 'ï¼Œ<span class="good">æœˆå»ºç”Ÿç”¨ç¥ï¼Œæ—º</span>';
                        else if (KE[mwx] === line.wx) ysContent += 'ï¼Œ<span class="warn">æœˆå»ºå…‹ç”¨ç¥ï¼Œè¡°</span>';
                        else if (mwx === line.wx) ysContent += 'ï¼Œ<span class="good">æœˆå»ºæ¯”å’Œç”¨ç¥ï¼Œæ—ºç›¸</span>';

                        // æ—¥è¾°å¯¹ç”¨ç¥
                        const dwx = DZ_WX[result.dayGZ.zhi];
                        if (SHENG[dwx] === line.wx) ysContent += 'ï¼Œ<span class="good">æ—¥è¾°ç”Ÿç”¨ç¥ï¼Œå¾—åŠ›</span>';
                        else if (KE[dwx] === line.wx) ysContent += 'ï¼Œ<span class="warn">æ—¥è¾°å…‹ç”¨ç¥ï¼Œå—åˆ¶</span>';

                        // åŠ¨çˆ»
                        if (result.moving[line.idx]) ysContent += 'ï¼Œç”¨ç¥å‘åŠ¨ï¼Œäº‹æœ‰å˜åŒ–';
                        ysContent += 'ã€‚';
                    });
                } else {
                    ysContent += `<span class="warn">å¦ä¸­ä¸ç°ç”¨ç¥ï¼Œéœ€çœ‹ä¼ç¥ã€‚</span>`;
                    const fus = result.fuShen.find(f => f.lqName === LIU_QIN[ys.lq]);
                    if (fus) {
                        ysContent += `ä¼ç¥${fus.lqName}${fus.ganZhi}${fus.wx}ï¼Œä¼äº${fus.underLQ}${fus.underGZ}ä¹‹ä¸‹ã€‚`;
                    }
                }
                blocks.push({ title: 'ç”¨ç¥åˆ†æ', content: ysContent });
            }

            // åŠ¨çˆ»åˆ†æ
            if (result.hasMoving) {
                let dongContent = '';
                result.moving.forEach((m, i) => {
                    if (!m) return;
                    const pos = 'åˆäºŒä¸‰å››äº”ä¸Š'[i];
                    const nj = result.naJiaOrig[i];
                    const gz = TIAN_GAN[nj.gan] + DI_ZHI[nj.zhi];
                    const lqName = LIU_QIN[nj.lq];
                    const chgNJ = result.naJiaChg[i];
                    const chgGZ = TIAN_GAN[chgNJ.gan] + DI_ZHI[chgNJ.zhi];
                    const chgLQ = LIU_QIN[chgNJ.lq];
                    dongContent += `${pos}çˆ»åŠ¨ï¼š${lqName}${gz}${WX_NAMES[nj.wx]} â†’ å˜ä¸º${chgLQ}${chgGZ}${WX_NAMES[chgNJ.wx]}`;
                    // åŠ¨å˜å…³ç³»
                    if (nj.wx === chgNJ.wx) dongContent += 'ï¼ˆæ¯”å’Œï¼Œå˜åŒ–ä¸å¤§ï¼‰';
                    else if (SHENG[chgNJ.wx] === nj.wx) dongContent += 'ï¼ˆå›å¤´ç”Ÿï¼Œå‰ï¼‰';
                    else if (KE[chgNJ.wx] === nj.wx) dongContent += 'ï¼ˆå›å¤´å…‹ï¼Œå‡¶ï¼‰';
                    dongContent += 'ã€‚';
                });
                blocks.push({ title: 'åŠ¨çˆ»åˆ†æ', content: dongContent });
            }

            // ç»¼åˆåˆ¤æ–­
            let summary = '';
            const shiMoving = result.moving[result.shiIdx];
            const yingMoving = result.moving[result.yingIdx];
            if (shiMoving) summary += 'ä¸–çˆ»å‘åŠ¨ï¼Œäº‹æƒ…ç”±æˆ‘æ–¹ä¸»å¯¼ã€‚';
            if (yingMoving) summary += 'åº”çˆ»å‘åŠ¨ï¼Œå¯¹æ–¹äº¦æœ‰å˜åŒ–ã€‚';

            const mwx = DZ_WX[result.monthZhi];
            const dwx = DZ_WX[result.dayGZ.zhi];
            // ä¸–çˆ»æ—ºè¡°
            if (SHENG[mwx] === shiWX || mwx === shiWX) summary += '<span class="good">ä¸–çˆ»å¾—æœˆä»¤ç”Ÿæ‰¶ï¼Œè‡ªèº«æ¡ä»¶æœ‰åˆ©ã€‚</span>';
            else if (KE[mwx] === shiWX) summary += '<span class="warn">ä¸–çˆ»å—æœˆå»ºå…‹åˆ¶ï¼Œè‡ªèº«æ¡ä»¶ä¸åˆ©ã€‚</span>';
            if (SHENG[dwx] === shiWX) summary += '<span class="good">ä¸–çˆ»å¾—æ—¥è¾°ç”ŸåŠ©ã€‚</span>';
            else if (KE[dwx] === shiWX) summary += '<span class="warn">ä¸–çˆ»è¢«æ—¥è¾°å…‹åˆ¶ã€‚</span>';

            if (!summary) summary = 'å¦è±¡å¹³ç¨³ï¼Œéœ€ç»“åˆå…·ä½“äº‹é¡¹è¯¦ç»†åˆ†æã€‚';
            summary += '<br><br><em style="color:var(--text3)">ä»¥ä¸Šåˆ†æä»…ä¾›å‚è€ƒï¼Œå…­çˆ»æ–­å¦éœ€ç»“åˆå®é™…æƒ…å†µç»¼åˆåˆ¤æ–­ã€‚</em>';
            blocks.push({ title: 'ç»¼åˆåˆ¤æ–­', content: summary });

            return blocks;
        }

        // ========== RENDER ==========
        function renderResult(result) {
            currentResult = result; // Save for export
            const area = document.getElementById('resultArea');
            area.classList.add('active');

            // Info tags
            const dayStr = formatGanZhi(result.dayGZ.gan, result.dayGZ.zhi);
            const yearStr = formatGanZhi(result.yearGZ.gan, result.yearGZ.zhi);
            const monthStr = TIAN_GAN[result.monthGan] + DI_ZHI[result.monthZhi];
            const q = document.getElementById('question').value;
            const tags = document.getElementById('infoTags');
            tags.innerHTML = `
    <span class="tag">ğŸ“… ${yearStr}å¹´ ${monthStr}æœˆ ${dayStr}æ—¥</span>
    <span class="tag">ğŸ› ${result.palaceName}å®« Â· ${WX_NAMES[result.palaceWX]}</span>
    <span class="tag">ğŸ“‹ ${result.posName}</span>
    ${q ? `<span class="tag">â“ ${q}</span>` : ''}
  `;

            // Hexagram panels
            const container = document.getElementById('hexContainer');
            let html = renderHexPanel(result, false);
            if (result.hasMoving) {
                html += `<div style="display:flex;align-items:center;font-size:28px;color:var(--gold3)">â </div>`;
                html += renderHexPanel(result, true);
            }
            container.innerHTML = html;

            // ä¼ç¥
            const fushenCard = document.getElementById('fushenCard');
            if (result.fuShen.length > 0) {
                fushenCard.style.display = 'block';
                let ft = '<table class="fushen-table"><tr><th>ä¼ç¥</th><th>å¹²æ”¯</th><th>äº”è¡Œ</th><th>ä¼äº</th></tr>';
                result.fuShen.forEach(f => {
                    ft += `<tr><td>${f.lqName}</td><td>${f.ganZhi}</td><td>${f.wx}</td>
        <td>${'åˆäºŒä¸‰å››äº”ä¸Š'[f.underLine]}çˆ» ${f.underLQ}${f.underGZ}ä¸‹</td></tr>`;
                });
                ft += '</table>';
                document.getElementById('fushenContent').innerHTML = ft;
            } else {
                fushenCard.style.display = 'none';
            }

            // Analysis
            const cat = document.getElementById('category').value;
            const blocks = generateAnalysis(result, cat);
            const as = document.getElementById('analysisSection');
            as.innerHTML = blocks.map(b => `
    <div class="analysis-block"><h3>${b.title}</h3><p>${b.content}</p></div>
  `).join('');

            area.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function renderHexPanel(result, isChanged) {
            const lines = isChanged ? result.changed : result.original;
            const naJia = isChanged ? result.naJiaChg : result.naJiaOrig;
            const upper = isChanged ? result.upperChg : result.upperOrig;
            const lower = isChanged ? result.lowerChg : result.lowerOrig;
            const name = isChanged ? result.hexNameChg : result.hexNameOrig;
            const label = isChanged ? 'å˜å¦' : 'æœ¬å¦';

            // For changed hexagram, compute its own palace for å…­äº²
            let shiIdx = -1, yingIdx = -1;
            if (!isChanged) {
                shiIdx = result.shiIdx;
                yingIdx = result.yingIdx;
            } else {
                shiIdx = result.chgShiIdx;
                yingIdx = result.chgYingIdx;
            }

            let html = `<div class="hex-panel"><div class="hex-panel-title">${name}</div>`;
            html += `<div class="hex-panel-subtitle">${label} Â· ${TRIGRAM_NATURE[upper]}${TRIGRAM_NATURE[lower]}å¦</div>`;
            html += `<div class="hex-table">`;

            const LINE_LABELS = ['åˆçˆ»', 'äºŒçˆ»', 'ä¸‰çˆ»', 'å››çˆ»', 'äº”çˆ»', 'ä¸Šçˆ»'];
            const liuShen = result.liuShen;

            for (let i = 5; i >= 0; i--) {
                const isYang = lines[i] === 1;
                const isMoving = !isChanged && result.moving[i];
                const nj = naJia[i];
                const gz = TIAN_GAN[nj.gan] + DI_ZHI[nj.zhi];
                const wxName = WX_NAMES[nj.wx];
                const lqName = LIU_QIN[nj.lq];
                const movingClass = isMoving ? ' line-moving' : '';

                let lineHTML;
                if (isYang) {
                    lineHTML = `<div class="yang-line"></div>${isMoving ? '<span class="moving-marker">â—‹</span>' : ''}`;
                } else {
                    lineHTML = `<div class="yin-line"><div class="yin-half"></div><div class="yin-half"></div></div>${isMoving ? '<span class="moving-marker">Ã—</span>' : ''}`;
                }

                let syLabel = '';
                if (i === shiIdx) syLabel = 'ä¸–';
                else if (i === yingIdx) syLabel = 'åº”';

                html += `<div class="hex-row${movingClass}">
      <span class="hex-spirit">${!isChanged ? liuShen[i] : ''}</span>
      <span class="hex-relative">${lqName}${DI_ZHI[nj.zhi]}</span>
      <div class="hex-line-wrap"><div class="hex-line">${lineHTML}</div></div>
      <span class="hex-nayin">${gz}${wxName}</span>
      <span class="hex-shiying">${syLabel}</span>
    </div>`;
            }

            html += `</div></div>`;
            return html;
        }

        // ========== CASTING METHODS ==========
        function autoShake() {
            const lines = [];
            for (let i = 0; i < 6; i++) {
                // Simulate 3 coins: 3=yin(head), 2=yang(tail). Sum of 3 coins: 6,7,8,9
                const coins = [0, 0, 0].map(() => Math.random() < 0.5 ? 3 : 2);
                lines.push(coins.reduce((a, b) => a + b, 0));
            }
            showCoinAnimation(lines);
        }

        function showCoinAnimation(lines) {
            const coinArea = document.getElementById('coinArea');
            coinArea.innerHTML = '<div class="coin flipping">å¦</div><div class="coin flipping" style="animation-delay:.1s">å¦</div><div class="coin flipping" style="animation-delay:.2s">å¦</div>';
            setTimeout(() => {
                coinArea.innerHTML = '';
                const result = analyzeHexagram(lines, new Date());
                renderResult(result);
            }, 800);
        }

        function timeShake() {
            const now = new Date();
            const y = now.getFullYear();
            const m = now.getMonth() + 1;
            const d = now.getDate();
            const h = now.getHours();
            const upperNum = (y + m + d) % 8;
            const lowerNum = (y + m + d + h) % 8;
            const movingLine = (y + m + d + h) % 6;

            // Generate lines from trigrams
            const upperBits = TRIGRAM_BITS[upperNum];
            const lowerBits = TRIGRAM_BITS[lowerNum];
            const allBits = [...lowerBits, ...upperBits];
            const lines = allBits.map((b, i) => {
                if (i === movingLine) return b === 1 ? 9 : 6; // moving
                return b === 1 ? 7 : 8; // static
            });
            showCoinAnimation(lines);
        }

        // ========== MANUAL SHAKE ==========
        let manualState = { lineIdx: 0, coinCount: 0, coins: [], allLines: [] };

        function startManual() {
            manualState = { lineIdx: 0, coinCount: 0, coins: [], allLines: [] };
            document.getElementById('manualPanel').classList.add('active');
            updateManualUI();
        }

        function cancelManual() {
            document.getElementById('manualPanel').classList.remove('active');
        }

        function updateManualUI() {
            const prog = document.getElementById('shakeProgress');
            let html = '';
            for (let i = 0; i < 6; i++) {
                const cls = i < manualState.lineIdx ? 'done' : (i === manualState.lineIdx ? 'current' : '');
                const label = i < manualState.lineIdx ? (manualState.allLines[i] % 2 === 1 ? 'âšŠ' : 'âš‹') : (i + 1);
                html += `<div class="shake-dot ${cls}">${label}</div>`;
            }
            prog.innerHTML = html;

            const coinArea = document.getElementById('coinArea');
            let coinHTML = '';
            for (let i = 0; i < 3; i++) {
                if (i < manualState.coinCount) {
                    coinHTML += `<div class="coin">${manualState.coins[i] === 1 ? 'å­—' : 'èƒŒ'}</div>`;
                } else {
                    coinHTML += `<div class="coin" style="opacity:.3">?</div>`;
                }
            }
            coinArea.innerHTML = coinHTML;

            const text = document.getElementById('coinResultText');
            if (manualState.lineIdx < 6) {
                text.textContent = `ç¬¬${'åˆäºŒä¸‰å››äº”ä¸Š'[manualState.lineIdx]}çˆ» Â· ç¬¬${manualState.coinCount + 1}æ¬¡æŠ•æ·`;
            }
        }

        function manualCoin(value) {
            if (manualState.lineIdx >= 6) return;
            manualState.coins.push(value);
            manualState.coinCount++;

            if (manualState.coinCount === 3) {
                // Calculate: å­—(1)=3, èƒŒ(0)=2
                const sum = manualState.coins.reduce((a, b) => a + (b === 1 ? 3 : 2), 0);
                manualState.allLines.push(sum);
                manualState.lineIdx++;
                manualState.coinCount = 0;
                manualState.coins = [];

                if (manualState.lineIdx === 6) {
                    document.getElementById('manualPanel').classList.remove('active');
                    const result = analyzeHexagram(manualState.allLines, new Date());
                    renderResult(result);
                    return;
                }
            }
            updateManualUI();
        }

        // ========== CUSTOM HEXAGRAM ==========
        function initCustomHexSelect() {
            const select = document.getElementById('customHexSelect');
            let html = '<option value="">è¯·é€‰æ‹©</option>';

            // Generate all 64 hexagrams
            for (let upper = 0; upper < 8; upper++) {
                for (let lower = 0; lower < 8; lower++) {
                    const name = GUA_NAMES[upper][lower];
                    const value = upper * 8 + lower;
                    html += `<option value="${value}">${name}</option>`;
                }
            }
            select.innerHTML = html;
        }

        function startCustom() {
            // Initialize select if not done
            if (document.getElementById('customHexSelect').options.length === 1) {
                initCustomHexSelect();
            }
            // Reset selections
            document.getElementById('customHexSelect').value = '';
            for (let i = 0; i < 6; i++) {
                document.getElementById(`customMove${i}`).checked = false;
            }
            document.getElementById('customPanel').classList.add('active');
        }

        function cancelCustom() {
            document.getElementById('customPanel').classList.remove('active');
        }

        function confirmCustom() {
            const hexValue = document.getElementById('customHexSelect').value;
            if (!hexValue) {
                alert('è¯·é€‰æ‹©å¦è±¡');
                return;
            }

            const value = parseInt(hexValue);
            const upper = Math.floor(value / 8);
            const lower = value % 8;

            // Get bits for upper and lower trigrams
            const upperBits = TRIGRAM_BITS[upper];
            const lowerBits = TRIGRAM_BITS[lower];
            const allBits = [...lowerBits, ...upperBits]; // bottom to top

            // Check which lines are moving
            const movingLines = [];
            for (let i = 0; i < 6; i++) {
                if (document.getElementById(`customMove${i}`).checked) {
                    movingLines.push(i);
                }
            }

            // Generate lines array (6,7,8,9)
            const lines = allBits.map((bit, i) => {
                const isMoving = movingLines.includes(i);
                if (bit === 1) {
                    // Yang line
                    return isMoving ? 9 : 7; // 9=è€é˜³(moving), 7=å°‘é˜³(static)
                } else {
                    // Yin line
                    return isMoving ? 6 : 8; // 6=è€é˜´(moving), 8=å°‘é˜´(static)
                }
            });

            document.getElementById('customPanel').classList.remove('active');
            const result = analyzeHexagram(lines, new Date());
            renderResult(result);
        }

        async function exportToClipboard() {
            if (!currentResult) return;
            const r = currentResult;

            // 1. Basic Info
            const q = document.getElementById('question').value || 'æœªæŒ‡å®šäº‹é¡¹';
            const cat = document.getElementById('category').options[document.getElementById('category').selectedIndex].text;
            const date = `${r.yearGZ.gan}${r.yearGZ.zhi}å¹´ ${TIAN_GAN[r.monthGan]}${DI_ZHI[r.monthZhi]}æœˆ ${TIAN_GAN[r.dayGZ.gan]}${DI_ZHI[r.dayGZ.zhi]}æ—¥`;

            let text = `ã€å…­çˆ»å åœæ±‚æµ‹ã€‘\n`;
            text += `æ±‚æµ‹äº‹é¡¹ï¼š${q}\n`;
            text += `äº‹é¡¹ç±»åˆ«ï¼š${cat}\n`;
            text += `èµ·å¦æ—¶é—´ï¼š${date} (ç©ºäº¡: ${getKongWang(r.dayGZ)})\n`;
            text += `\nã€å¦è±¡ä¿¡æ¯ã€‘\n`;
            text += `æœ¬å¦ï¼š${r.hexNameOrig} (${r.palaceName}å®«${r.posName})\n`;
            if (r.hasMoving) text += `å˜å¦ï¼š${r.hexNameChg}\n`;
            else text += `å˜å¦ï¼š(æ— )\n`;

            text += `\nã€çˆ»ä½è¯¦æƒ…ã€‘\n`;
            // Header
            text += `å…­ç¥\tä¼ç¥\tã€æœ¬å¦ã€‘\t\t\tå˜å¦\n`;

            for (let i = 5; i >= 0; i--) {
                const nj = r.naJiaOrig[i];
                const isMoving = r.moving[i];
                const lineName = (nj.gan % 2 === 1 ? 'ä¹' : 'å…­') + 'åˆäºŒä¸‰å››äº”ä¸Š'[i]; // Roughly

                // Spirit
                let row = `${r.liuShen[i]}\t`;

                // Fushen
                const fu = r.fuShen.find(f => f.underLine === i);
                row += fu ? `${fu.lqName}${fu.ganZhi}` : ' -- ';
                row += '\t';

                // Original Line
                const shiying = (i === r.shiIdx ? 'ä¸–' : (i === r.yingIdx ? 'åº”' : '  '));
                const lq = LIU_QIN[nj.lq];
                const zhi = DI_ZHI[nj.zhi]; // Branch
                const gz = TIAN_GAN[nj.gan] + DI_ZHI[nj.zhi];
                const wx = WX_NAMES[nj.wx];
                const moveMark = isMoving ? (r.original[i] === 1 ? ' O-> ' : ' X-> ') : '     ';

                row += `${shiying} ${lq}${zhi} ${gz}${wx} ${moveMark}`;

                // Changed Line
                if (isMoving) {
                    const cnj = r.naJiaChg[i];
                    const clq = LIU_QIN[cnj.lq];
                    const czhi = DI_ZHI[cnj.zhi];
                    const cgz = TIAN_GAN[cnj.gan] + DI_ZHI[cnj.zhi];
                    const cwx = WX_NAMES[cnj.wx];
                    row += `${clq}${czhi} ${cgz}${cwx}`;
                }

                text += row + '\n';
            }

            text += `\nã€AI åˆ†ææŒ‡ä»¤ã€‘\n`;
            text += `ä½œä¸ºä¸€ä¸ªç²¾é€šå…­çˆ»é¢„æµ‹çš„ä¸“å®¶ï¼Œè¯·æ ¹æ®ä¸Šè¿°å¦è±¡ä¿¡æ¯è¿›è¡Œè¯¦ç»†åˆ†æã€‚\n`;
            text += `1. åˆ†æä¸–åº”å…³ç³»ï¼Œåˆ¤æ–­æ±‚æµ‹äººä¸äº‹ç‰©çš„å…³ç³»ã€‚\n`;
            text += `2. æ ¹æ®æ±‚æµ‹ç±»åˆ«ï¼ˆ${cat}ï¼‰ç¡®å®šç”¨ç¥ï¼Œåˆ†æç”¨ç¥æ—ºè¡°ï¼ˆæœˆå»ºã€æ—¥è¾°ã€åŠ¨çˆ»çš„å½±å“ï¼‰ã€‚\n`;
            text += `3. åˆ†æåŠ¨çˆ»çš„ç”Ÿå…‹å†²åˆï¼Œä»¥åŠå˜çˆ»çš„å›å¤´ç”Ÿ/å…‹ã€‚\n`;
            text += `4. ç»“åˆå…­ç¥å«ä¹‰ï¼Œåˆ†æäº‹æƒ…çš„æ€§è´¨å’Œç»†èŠ‚ã€‚\n`;
            text += `5. ç»¼åˆç»™å‡ºå‰å‡¶åˆ¤æ–­å’Œå»ºè®®ã€‚\n`;

            try {
                await navigator.clipboard.writeText(text);
                alert('âœ¨ å¦è±¡ä¸AIæç¤ºè¯å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼\næ‚¨å¯ä»¥ç›´æ¥ç²˜è´´å‘é€ç»™AIåŠ©æ‰‹è¿›è¡Œè§£è¯»ã€‚');
            } catch (err) {
                console.error('Failed to copy: ', err);
                alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶ã€‚');
            }
        }

        function getKongWang(dayGZ) {
            // æ—¬ç©º calculation: (DayZhi - DayGan) / 2 ... simplify logic
            // ç”²å­0æ—¬ -> æˆŒäº¥(10,11)
            // (zhi - gan + 10) % 12 -> gives the first branch of the next decade? No.
            // ç”²(0)å­(0) -> 0. 
            // æ—¬ç©º index = (zhi - gan + 10) % 12? 
            // ex: ç”²(0)å­(0) -> 10(æˆŒ), 11(äº¥). (0-0+10)%12 = 10. Correct.
            // ex: ç”²(0)å¯…(2) -> (2-0+10)%12 = 0(å­), 1(ä¸‘). Correct.
            const start = (dayGZ.zhi - dayGZ.gan + 10) % 12;
            return DI_ZHI[start] + DI_ZHI[(start + 1) % 12];
        }
    </script>
</body>

</html>